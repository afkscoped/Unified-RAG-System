"""
Narrative Manager

Manages overall story state including:
- Chapter progression
- Full story history
- Export functionality
"""

from typing import Dict, List, Optional, Any
from datetime import datetime
from pathlib import Path
from loguru import logger


class NarrativeManager:
    """
    Manages story state and provides utilities for story operations.
    
    Handles:
    - Story metadata (title, author, etc.)
    - Chapter management
    - Story export to various formats
    - Story persistence
    """
    
    def __init__(self, title: str = "Untitled Story"):
        """
        Initialize narrative manager.
        
        Args:
            title: Story title
        """
        self.title = title
        self.author = ""
        self.created_at = datetime.now()
        self.last_modified = datetime.now()
        
        # Story content
        self.chapters: Dict[int, Dict] = {}  # chapter_num -> chapter data
        self.current_chapter = 1
        
        # Metadata
        self.synopsis = ""
        self.genres: List[str] = []
        self.settings: List[str] = []
        
        logger.info(f"NarrativeManager initialized for '{title}'")
    
    def add_segment(
        self,
        chapter: int,
        text: str,
        method: str = "hybrid",
        metadata: Optional[Dict] = None
    ) -> None:
        """
        Add a story segment to a chapter.
        
        Args:
            chapter: Chapter number
            text: Story text
            method: Generation method used
            metadata: Optional additional metadata
        """
        if chapter not in self.chapters:
            self.chapters[chapter] = {
                "number": chapter,
                "title": f"Chapter {chapter}",
                "segments": [],
                "created_at": datetime.now().isoformat()
            }
        
        self.chapters[chapter]["segments"].append({
            "text": text,
            "method": method,
            "timestamp": datetime.now().isoformat(),
            "metadata": metadata or {}
        })
        
        self.last_modified = datetime.now()
        self.current_chapter = max(self.current_chapter, chapter)
        
        logger.debug(f"Added segment to chapter {chapter}")
    
    def get_chapter(self, chapter: int) -> Optional[Dict]:
        """Get chapter data."""
        return self.chapters.get(chapter)
    
    def get_chapter_text(self, chapter: int) -> str:
        """Get full text for a chapter."""
        if chapter not in self.chapters:
            return ""
        
        segments = self.chapters[chapter].get("segments", [])
        return "\n\n".join([s["text"] for s in segments])
    
    def get_full_story(self, method_filter: Optional[str] = None) -> str:
        """
        Get full story text.
        
        Args:
            method_filter: Optional filter for generation method
            
        Returns:
            Complete story text
        """
        story_parts = [f"# {self.title}\n"]
        
        if self.author:
            story_parts.append(f"*By {self.author}*\n")
        
        for chapter_num in sorted(self.chapters.keys()):
            chapter = self.chapters[chapter_num]
            story_parts.append(f"\n## {chapter.get('title', f'Chapter {chapter_num}')}\n")
            
            for segment in chapter.get("segments", []):
                if method_filter and segment.get("method") != method_filter:
                    continue
                story_parts.append(segment["text"])
        
        return "\n\n".join(story_parts)
    
    def set_chapter_title(self, chapter: int, title: str) -> None:
        """Set title for a chapter."""
        if chapter in self.chapters:
            self.chapters[chapter]["title"] = title
            self.last_modified = datetime.now()
    
    def export_markdown(self, path: str, method_filter: Optional[str] = None) -> None:
        """
        Export story to Markdown file.
        
        Args:
            path: Output file path
            method_filter: Optional filter for generation method
        """
        content = self.get_full_story(method_filter)
        
        # Add metadata footer
        content += f"\n\n---\n"
        content += f"*Generated by StoryWeaver*\n"
        content += f"*Created: {self.created_at.strftime('%Y-%m-%d')}*\n"
        content += f"*Last modified: {self.last_modified.strftime('%Y-%m-%d %H:%M')}*\n"
        
        Path(path).write_text(content, encoding="utf-8")
        logger.info(f"Story exported to {path}")
    
    def export_json(self, path: str) -> None:
        """Export story as JSON."""
        import json
        
        data = {
            "title": self.title,
            "author": self.author,
            "synopsis": self.synopsis,
            "genres": self.genres,
            "settings": self.settings,
            "created_at": self.created_at.isoformat(),
            "last_modified": self.last_modified.isoformat(),
            "chapters": self.chapters,
            "total_chapters": len(self.chapters)
        }
        
        Path(path).write_text(json.dumps(data, indent=2), encoding="utf-8")
        logger.info(f"Story exported to {path}")
    
    def get_statistics(self) -> Dict:
        """Get story statistics."""
        total_words = 0
        total_segments = 0
        methods_used = {}
        
        for chapter in self.chapters.values():
            for segment in chapter.get("segments", []):
                total_segments += 1
                total_words += len(segment["text"].split())
                method = segment.get("method", "unknown")
                methods_used[method] = methods_used.get(method, 0) + 1
        
        return {
            "title": self.title,
            "total_chapters": len(self.chapters),
            "total_segments": total_segments,
            "total_words": total_words,
            "methods_used": methods_used,
            "created_at": self.created_at.isoformat(),
            "last_modified": self.last_modified.isoformat()
        }
    
    def clear(self) -> None:
        """Clear all story content."""
        self.chapters = {}
        self.current_chapter = 1
        self.last_modified = datetime.now()
        logger.info("Story content cleared")
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization."""
        return {
            "title": self.title,
            "author": self.author,
            "synopsis": self.synopsis,
            "genres": self.genres,
            "settings": self.settings,
            "created_at": self.created_at.isoformat(),
            "last_modified": self.last_modified.isoformat(),
            "current_chapter": self.current_chapter,
            "chapters": self.chapters
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> "NarrativeManager":
        """Create from dictionary."""
        manager = cls(data.get("title", "Untitled"))
        manager.author = data.get("author", "")
        manager.synopsis = data.get("synopsis", "")
        manager.genres = data.get("genres", [])
        manager.settings = data.get("settings", [])
        manager.current_chapter = data.get("current_chapter", 1)
        manager.chapters = data.get("chapters", {})
        
        # Convert chapter keys to int
        manager.chapters = {int(k): v for k, v in manager.chapters.items()}
        
        return manager
